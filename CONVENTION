==== CODING CONVENTIONS ====

=== Folder Structure
All code shall reside in /src
The code is divided in various modules, each of which contains functions and
classes that have similar functionality, eg. the graphics -module might contain
a sprite class and blitting functions.
Each module resides in its own folder. All code in a module is contained in a
namespace named after the folder.

=== Files Generally
File names shall not contain characters other than latin letters and numbers.
That is, a-z, A-Z and 0-9.
Files are to be named after the class they define or declare, or by a short name
describing their contents.
Related files, for example headers and their implementation files are to be named
similiarly, the sole difference being the file extension.

=== Header Files
Header files shall use the extension .h

include guards are formatted in the following way:
	#ifndef SLC_MODULE_FILE_H
	#define SLC_MODULE_FILE_H
	<code>
	#endif
where
	MODULE is the module the header belongs to in all-caps and
	FILE is the filename of the header without the extension .h in all-caps

 == Forward Header
 Forward declarations, enumerations and other public data is to be placed in
 their own special header files, called forward headers (Header_fwd from now on)
 headers include their forward-declaring headers
 the forward declaring header is named as follows:
 	header_fwd.h
 where
 	header is the filename of the header without the extension .h
 for consistency, every header has a corresponding forward header
 class-scoped typedefs, enums or other data might require that class to be put in the forward-header

 == Inline Files
 inline files use the extension .inl
 inline files are used whenever you want to enable inlining of functions (e.g. templated classes)
 an inline file is an implementation file included in a header
 Note: though include files are used as a header, they do not obey their rules. Instead they follow the rules of implementation files.

=== Implementation Files
implementation files use the .cpp extension

TBD: usage of a precompiled-header
C++ headers are included first
followed by 3rd party headers
followed by this projects headers
the order of headers within those constrains is alphabetical

=== Functions
functions use names descriptive to their purpose
function are named in lowerCamelCase

 == Member functions
 non-modifying member-functions have a space before the const-keyword
 	T getSomething() const;
  = Accessors
  most member-variables will use accessors like in this example:
  	T getVar();
  or
TBD:	T& getVarRef();
  and
  	void setVar(T var);
  or
  	void setVar(T &var);
  (note: the appropriate usage of const was left out in this example)

 == Return types
 if the return type is a pointer or reference, the star/and-symbol are to be attached to the type
 	T& iReturnT();

 == Arguments
 function arguments are declared as discussed in the Variables and Constants section
 the void for argument-less functions is not explicitly written

=== Assembly
if you feel that you can provide a better assembly than the compiler can, write it
use the preprocessor to determine if it can be used
make sure that there is a C++-version of it for portability reasons

=== Variables and Constants
constants use the same convention as variables

variables use descriptive names
variables are named in lowerCamelCase

declarations of a pointer or reference-type have the star or and-symbol attached to their name

a descriptive typedef usually helps for complicated type names (e.g. templated classes)

 == Member Variables
 member variables are usually private and use accessors

=== Parentheses and Indentation:
the opening curly bracket is placed in the same line as the statement, with no space in between
the closing curly bracket is placed in the same height as the associated control statement
 exceptions:
 empty function-bodies: in this case simply '{}' is written
 namespaces are clustered in one line with one space to the right between each declaration
 the closing brackets may also be clustered in one line with one space between each declaration
 an empty line follows after the last opening bracket
 an empty line follows before the first closing bracket
 	namespace a{ namespace b{ namespace c{

 	  //declerations/definitions

 	}}}
 the square brackets (array subscript) are used without any additional spaces
 	a[0]++;
 inequality-signs (angle brackets) -> see either the section Operators or Templates
 round brackets are used without any additional spaces
 	if(a){
 	  b(c);
 	} else{
 	  b(-c);
 	}
 
each scope is indented by two spaces
opening curly brackets are placed in the same line as the declaration
the opening curly bracket is followed by a new line
closing curly brackets are not in the same line as their opening bracket and are placed in the same height as the control statement
 one-line-function definitions inside class declaration may have the definition and the closing curly bracket in the same line as the opening one
	 class A{
	 public:
	   A(void);
	   ~A(void);
	 
	   void setVar(const T &v){ m_var = v;}
	   T& getVarRef(void){ return m_var;}
	
	 private:
	   T m_var;
 };
 
single control-statements (if no else associated, loops) do not have curly brackets attached to them if only one command is in the boy, but the body is still placed after a new line
	if(something)
	  somethingHappened();
 
switch-statements have their cases in the same height as the switch-statement
the commands of a case for a switch-statement are indented by two spaces and are not in the same line as the case
the break for the cases of a switch-statement is on the same height as its corresponding case
	switch(a){
	case 1:
	  doSomething();
	  doSomethingElse();
	break;
	case 2:
	  doSomethingElse();
	break;
	[...]
	}

TBD: one line is broken into multiple lines if the line without indentation is longer than 75 characters (10 characters tolerance)
 
initializer-lists are written in one line after the declaration with two space-characters indentation and no additional space-character to its right
	SomeClass::SomeClass(T1 arg1, T2 arg2)
	  :member1(arg1), member2(arg2)

the colon for inheritance has a space to its right, but none to its left operant
additionally no new line is used, if appropriate
	class a: public b

=== Classes and Structs
structs generally follow the conventions of classes, except when specifically noted

classes are named with UpperCamelCase
classes have descriptive names
classes should have accessors for all their member-variables

accessors are generally named after their variable
getters are prefixed with get
TBD: getters returning references are postfixed Ref
setters are prefixed with set

initialization-time singletons have their instance-name equal to their class name
post-initialization-time singletons have to declare their constructor and the operator new and delete non-public and are to provide a static getter for an instance
TBD: A uniform getter would probably be best.

TBD: ordering of macros and public/private/protected inner structs/classes/enums/typedefs/functions/con/destructors/...

only define short one-liners directly in class definitions
use a single line for that, if appropriate

 == Structs
 TBD: use structs for data accumulation purposes only
      structs should not have accessors

TBD: prefix interfaces with an I

=== Templates
the typename-keyword is used to define template-class-parameters
parameters use descriptive names

the inequality-signs (angle brackets) are used without additional space-characters
note: C++03 does not play nice with template<typename A<typename B>>, as such you place a space-character at the end of the closing greater-than-sign
	template<typename T, typename U<typename UT = T> >
	class A{ ... };
TBD: use the C++0x compiler extensions to allow this?

after the complete template-declaration a new line follows (this also applies to (partial) template specialization)
exceptions:
 for function-declarations and template specialization no new line is used
 for partial template specialization with multiple template-keywords no new line, but a space-character is used in between
 	template<typename A> template<typename B>
 for the function-call or class-instantiation there no new line is used
 	A<int, list> var;

=== Semicolons and Commas
after a semicolon a new line usually follows for the next command
exceptions:
 for-loops just use a single space-character to their right and no additional character to their left
 	for(std::size_t i = 0; i < 10; ++i)

a comma has a single space-character to their right, no additional character to their left
note: it makes to difference in formatting if the comma is used as separator or operator

=== Operators
unary operators use no space-character the operator and the variable
	++a;

non-unary operators use space-characters between each variable
	a = b ? (c + d) : (c - d);
exceptions:
 the following operators are used without space-characters in between:
 function call, array subscript, member, member by pointer, bind pointer to member by pointer, bind pointer to member by reference, scope resolution, pointer to member
 	a[0].b->c();

=== Comments
Comments will have a single space after the comment token
	// Like this

TBD: each header has a comment at its top, explaining its purpose
comment code, which purpose or inner workings is hard to determine
use the preprocessor to out-comment code
place a single-line comment at the top to explain why the code is commented out

things, that are left to be done, are signed via a 'TODO: ' in the line before the point where it should be done in a single-line comment, followed by a description on what is there to be done
	// TODO: look into the doSomethingDifferently-function ;z33ky
things, that need fixing, are signed via a 'FIXME: ' in the line before the point that needs fixing in a single-line comment, followed by a description on what is there to be fixed
	// FIXME: crashes when the index in bigger than 42 ;z33ky
things, that work, but use some ugly code to work ('hacks') are signed via a 'HACK: ' in the line before the point that includes the work-around, followed by a description on what was worked around and why it was required to be worked around
	// HACK: many problems arise from throwing an exception here, as such we are silently ignoring the error ;z33ky
TODOs, FIXMEs and HACKs are usually signed from the person who wrote them, by putting ' ;<name>' after the description for contacting purposes
any further notices are placed in a new line under the comment and prefixed with '//^- ' and also signed like TODOs, FIXMEs and HACKs
	// FIXME: crashes when the index is bigger than 42 ;z33ky
	// ^- might be related to the FIXME in Bugger::FortyTwoCrash ;f00by
use multiple single-line comments for TODOs, HACKs and FIXMEs if you have to break into a new line in a comment and indent by two spaces after the following '//'

=== Preprocessor

 == Macros
 macros are usually named in ALL_CAPS with an underscore separating the words, if needed
 be careful with macros and try to enclose them with braces of some kind
 usually you should write function-like macros to require an additional semicolon at their end

==== OTHER ====
z33ky's document can be found at http://pastebin.com/CbTaexhZ